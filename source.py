from pyawp import utils
import pyawp
import numpy as np

class Source(object):
    """
    This class is used for creating old-style AWP sources and writing them to
    disk.
    """

    def __init__(self, config, **kwargs):
        
        if 'grid_num' in kwargs:
            self.grid_num = kwargs['grid_num']
        else:
            self.grid_num = 0

        self.settings = get_defaults(config, self.grid_num)
        self.sources = self.init_sources()
        self.t = np.linspace(0, self.settings.tmax, self.settings.nst)


        for arg in kwargs:
            self.settings[arg] = kwargs[arg]

    def init_sources(self):
        mxx = np.zeros((self.settings.nst,))
        myy = np.zeros((self.settings.nst,))
        mzz = np.zeros((self.settings.nst,))
        mxy = np.zeros((self.settings.nst,))
        mxz = np.zeros((self.settings.nst,))
        myz = np.zeros((self.settings.nst,))
        sources = [0]*self.num_sources
        for i in range(self.settings.nsrc): 
            sources[i] = pyawp.MomentTensor(mxx, myy, mzz, mxy, mxz, myz) 
        return sources

    def file(self):
        return self.settings.filename + "_%d"% self.grid_num

    def write(self):
        overwrite = 1
        if self.topo_auto_adjust:
            self.topo_adjust()
        for src in self.sources:
            write(self.file(), 
                  src.stack(), np.array(src.pos), overwrite,
                  prec=self.settings.prec)
            if overwrite:
                overwrite = 0

    def info(self):
        for i in range(self.settings.nsrc): 
            print("source: %d position = [%d %d %d] fmax = %g"
                    % (i, self.sources[i].pos[0], self.sources[i].pos[1],
                    self.sources[i].pos[2], self.fmax(i), 
                    ))

    def __str__(self):
        return str(vars(self.settings))

    def fmax(self, i):
        return self.settings.fp[i]*self.settings.fmax_factor

    def topo_adjust(self):
        """
        Fix source positions when topography is enabled. This will reposition
        the source that it is the same number of points away from the free
        surface as the regular AWP-version.
        """
        if not self.settings.use_topo:
            return
        for i, src in enumerate(self.sources):
            self.sources[i].pos[2] += 1

    @property
    def topo_auto_adjust(self):
        return self.settings.topo_auto_adjust

    @property
    def num_sources(self):
        return self.settings.nsrc

def read(filename):
    import numpy as np
    import os

# Get source position
    pos = np.fromfile(filename, count=3, dtype=np.int32)
    fh = open(filename, mode='rb')
    # Get source data
    fh.seek(4*3, os.SEEK_SET)
    M = np.fromfile(fh, dtype=np.float32)
    out = np.reshape(M, (int(M.shape[0]/6), int(6))).transpose()
    fh.close()
    return pos, out

def write(filename, M, pos, overwrite=0, prec=None):
    """
    Write source to disk

    Arguments:
        filename : File to write to.
        M : Array of data (can be generated by calling MomentTensor.stack()) 
        pos : Source position
        overwrite : Overwrite file if True.

    """
    import numpy as np
    import os
   
    if overwrite:
        mode = 'wb'
    else:
        mode = 'ab'

    if not prec:
        prec = np.float32
    fh = open(filename, mode=mode)
    pos.astype(np.int32).tofile(fh)
    fh.close()
    fh = open(filename, mode='ab')
    M.transpose().astype(prec).tofile(fh)
    fh.close()



def write_source_input(filename, params, types, x, y, z, verbose=True):
    write_input(filename, params, types, x, y, z, verbose=verbose,
            is_source=True)

def write_recv_input(filename, params, types, x, y, z, verbose=True):
    write_input(filename, params, types, x, y, z, verbose=verbose,
            is_source=False)

def write_input(filename, params, types, x, y, z, verbose=True, is_source=True):
    """
    Write source or receiver configuration file
    """

    assert 'steps' in params

    if not 'gpu_buffer_size' in params:
        params['gpu_buffer_size'] = params['steps']

    if not 'cpu_buffer_size' in params:
        params['cpu_buffer_size'] = 1

    if not is_source and not 'num_writes' in params:
        params['num_writes'] = 1

    if not 'degree' in params:
        params['degree'] = 0

    # Check that buffer size is ok
    if is_source:
        assert params['gpu_buffer_size'] * params['cpu_buffer_size'] == \
               params['steps']

    # Polynomial degree above 3 can cause parallel bugs and is therefore
    # forbidden (and also useless)
    assert params['degree'] <= 3
    assert params['degree'] >= 0

    with open(filename, "w") as f:
        # Write header
        for key in params:
            val = str(params[key])
            if 'gpu_buffer_size' in key         \
                or 'cpu_buffer_size' in key     \
                or 'steps' in key               \
                or 'degree' in key:
                val = int(float(val))
            if 'version' in key:
                f.write("%s\n" % (val) )
            else:
                f.write("%s=%s\n" % (key, str(val)) )

#Write coordinates
        x = np.array(x)
        y = np.array(y)
        z = np.array(z)
        assert x.shape == y.shape
        assert x.shape == z.shape
        f.write('length=%d\n' % x.shape[0])
        f.write('\ncoordinates\n')
        for ti, xi, yi, zi in zip(types, x, y, z):
            f.write("%d %f %f %f \n"% (ti, xi, yi, zi))
        if verbose:
            if is_source:
                print("Wrote %d source(s): %s" % (x.shape[0], filename))
            if not is_source:
                print("Wrote %d receiver(s): %s" % (x.shape[0], filename))


def write_source(filename, mxx, myy, mzz, mxy, mxz, myz, verbose=True):
    """

    Write moment tensor source data.

    """
    mxx = np.array(mxx).astype(np.float32)
    myy = np.array(myy).astype(np.float32)
    mzz = np.array(mzz).astype(np.float32)
    mxy = np.array(mxy).astype(np.float32)
    mxz = np.array(mxz).astype(np.float32)
    myz = np.array(myz).astype(np.float32)

    mxx.tofile('%s_xx' % filename)
    myy.tofile('%s_yy' % filename)
    mzz.tofile('%s_zz' % filename)
    mxy.tofile('%s_xy' % filename)
    mxz.tofile('%s_xz' % filename)
    myz.tofile('%s_yz' % filename)

    if verbose:
            print("Wrote source binary files: %s_{xx, yy, zz, xy, xz, yz}" %
                    (filename))

def write_force(filename, fx, fy, fz, verbose=True):
    """

    Write point force data.

    """
    fx = np.array(fx).astype(np.float32)
    fy = np.array(fy).astype(np.float32)
    fz = np.array(fz).astype(np.float32)

    fx.tofile('%s_fx' % filename)
    fy.tofile('%s_fy' % filename)
    fz.tofile('%s_fz' % filename)

    if verbose:
            print("Wrote force binary files: %s_{fx, fy, fz}" %
                    (filename))


def resolution(max_frequency, gridspacing, min_wavespeed):
    """
    Determine the number of grid points per minimum wavelength.

    Input arguments:
        max_frequency : Maximum frequency that must be resolved by the
            simulation.
        gridspacing : The grid spacing used in the simulation.
        min_wavespeed : The minimum wave speed used in the simulation.

    Returns:
        Number of grid points per minimum wavelength (float)

    """
    return min_wavespeed*1.0/(max_frequency*gridspacing)

def get_defaults(cfg, grid_num):
        src = utils.Struct()
        src.fmax_factor = 2.5
        src.tmax = cfg.settings.tmax
        src.dt = cfg.settings.dt
        src.nsrc = cfg.settings.nsrc[grid_num]
        src.nst = np.int(np.ceil(src.tmax/src.dt))
        src.fp = np.ones((src.nsrc,))
        src.t0 = 2*np.ones((src.nsrc,))
        src.filename = cfg.file(cfg.settings.source)
        src.h = cfg.settings.h
        src.use_topo = cfg.settings.use_topo
        src.topo_auto_adjust = cfg.settings.topo_auto_adjust
        src.prec = cfg.settings.prec
        return src
